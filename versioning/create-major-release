#!/bin/bash

# TODO - verify that there is no version.txt in master branch
# TODO - add automatic diff between this and previous release

function errexit()
{
  >&2 echo "! Error: "$1
  exit 1
}

usage() {
    echo "USAGE: create-major-release [OPTIONS]"
    echo ""
    echo "OPTIONS:"
    echo "  -h        print this message and exit"
    echo "  -f        do not prompt for confirmation"
    echo "  -n        do not fetch tags from Git remote"
    echo "  -b bump   version bump (major/minor)"
    echo ""
    echo "RETURNS:"
    echo "  0     success"
    echo "  1     error"
    exit 1
}

skip_confirmation=""
skip_tags_fetch=""
version_bump=""

while getopts "fhnb:" arg; do
  case "${arg}" in
    f)
      skip_confirmation="TRUE"
      ;;
    n)
      skip_tags_fetch="TRUE"
      ;;
    b)
      version_bump=$OPTARG
      ;;
    h)
      usage
      ;;
  esac
done

shift $((OPTIND-1))

if [[ $version_bump != "major" &&  $version_bump != "minor" ]]; then
  errexit "invalid release type - use -b major/minor"
fi

result=0

version_header="version.txt"

current_branch=$(git rev-parse --abbrev-ref HEAD)
r=$?
if [ "$r" -ne 0 ]; then
  errexit "\"git rev-parse\" failed with return code $r"
elif [ "$current_branch" != "master" ]; then
  errexit "not in master branch"
fi

git_status=$(git status --porcelain)
r=$?
if [ "$r" -ne 0 ]; then
  errexit "\"git status\" failed with return code $r"
elif [ ! -z "$git_status" ]; then
  echo $git_status
  errexit "uncommitted changes or untracked files present"
fi

if [ "$skip_tags_fetch" = "TRUE" ]; then
  echo "Not fetching tags from Git remote"
else
  echo "Fetching tags from Git remote"
  git fetch --tags
  r=$?
  if [ "$r" -ne 0 ]; then
    errexit "\"git fetch\" failed with return code $r"
  fi
fi

# Uses $version_bump
function get_new_version()
{
  CUR_MAJ=0
  CUR_MIN=0
  CUR_PAT=0

  tags=$(git tag)

  VER_PATT='/^v(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-rc[1-9][0-9]*)?$/'

  for tag in $tags
  do
    #echo tag: $tag
    line=$(echo $tag | awk -v patt=$VER_PATT '{split(substr($1, 2, length($1)-1), a, "\."); print a[1], a[2], a[3]}')
    MAJ=$(echo $line | awk '{print $1}')
    MIN=$(echo $line | awk '{print $2}')
    PAT=$(echo $line | awk '{print $3}')

    if [[ $MAJ != "" && $MIN != "" ]]; then
      #echo current line: $MAJ.$MIN.$PAT
      if [[ $MAJ > $CUR_MAJ ||                     \
            $MAJ == $CUR_MAJ && $MIN > $CUR_MIN || \
            $MAJ == $CUR_MAJ && $MIN == $CUR_MIN && $PAT > $CUR_PAT ]]; then
        CUR_MAJ=$MAJ
        CUR_MIN=$MIN
        CUR_PAT=$PAT
      fi
    fi
  done

  PREV_REL="$CUR_MAJ.$CUR_MIN.$CUR_PAT"

  if [[ $version_bump == "major" ]]; then
    newmaj=$(( $CUR_MAJ + 1 ))
    version="$newmaj.0.0"
  elif [[ $version_bump == "minor" ]]; then
    newmin=$(( $CUR_MIN + 1 ))
    version="$CUR_MAJ.$newmin.0"
  fi
}

echo "Determine latest release"
get_new_version
echo "Previous release: $PREV_REL"
echo "New release     : $version"
release_branch="release-$version"
release_tag="v$version"

echo "Changes to be made:"
echo "  new major version will be $next_major_version"
echo "  release tag will be $release_tag"
echo "  will update version in file \"$version_header\""
echo "  will create and checkout branch \"$release_branch\""
echo "You will be prompted for a tag annotation"

if [ "$skip_confirmation" != "TRUE" ]; then
  echo ""
  read -p "Would you like to proceed? [y/N]: " choice
  if [[ $choice != 'y' ]]; then
      echo "Exiting on user command"
      exit 1
  fi
fi

git checkout -b "$release_branch" || errexit "failed to checkout branch \"$release_branch\""
echo $version > $version_header   || errexit "unable to create version file \"$version_header\""
git add "$version_header"         || errexit "git add failed"
git commit -m "create-major-release $version"  || errexit "git commit failed"
git tag -a "$release_tag"         || errexit "git tag failed for \"$release_tag\""

echo "Release $version created. Please remember to push with"
echo "  git push origin $release_branch --follow-tags"
exit 0
