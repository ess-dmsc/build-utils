#!/bin/bash

# TODO - verify that there is no version.txt in master branch
# TODO - add automatic diff between this and previous release

function errexit()
{
  >&2 echo "! Error: "$1
  exit 1
}

usage() {
    echo "USAGE: create-major-release [OPTIONS]"
    echo ""
    echo "OPTIONS:"
    echo "  -h        print this message and exit"
    echo "  -f        do not prompt for confirmation"
    echo "  -n        do not fetch tags from Git remote"
    echo "  -b bump   version bump (major/minor)"
    echo ""
    echo "RETURNS:"
    echo "  0     success"
    echo "  1     error"
    exit 1
}

skip_confirmation=""
skip_tags_fetch=""
version_bump=""

while getopts "fhnb:" arg; do
  case "${arg}" in
    f)
      skip_confirmation="TRUE"
      ;;
    n)
      skip_tags_fetch="TRUE"
      ;;
    b)
      version_bump=$OPTARG
      ;;
    h)
      usage
      ;;
  esac
done

shift $((OPTIND-1))

if [[ $version_bump != "major" &&  $version_bump != "minor" ]]; then
  errexit "invalid release type - use -bmajor/minor"
fi

result=0

version_header="version.txt"

current_branch=$(git rev-parse --abbrev-ref HEAD)
r=$?
if [ "$r" -ne 0 ]; then
  errexit "\"git rev-parse\" failed with return code $r"
elif [ "$current_branch" != "master" ]; then
  errexit "not in master branch"
fi

git_status=$(git status --porcelain)
r=$?
if [ "$r" -ne 0 ]; then
  errexit "\"git status\" failed with return code $r"
elif [ ! -z "$git_status" ]; then
  echo $git_status
  errexit "uncommitted changes or untracked files present"
fi

if [ "$skip_tags_fetch" = "TRUE" ]; then
  echo "Not fetching tags from Git remote"
else
  echo "Fetching tags from Git remote"
  git fetch --tags
  r=$?
  if [ "$r" -ne 0 ]; then
    errexit "\"git fetch\" failed with return code $r"
  fi
fi

# Uses $version_bump
function get_new_version()
{
  CUR_MAJ=0
  CUR_MIN=0
  CUR_PATCH=0

  tags=$(git tag)
  #echo $tags

  for tag in $tags
  do
    #echo tag: $tag
    MAJ=$(echo $tag | awk '/^v(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-rc[1-9][0-9]*)?$/ {split(substr($1, 2, length($1)-1), a, "\."); print a[1]}')
    MIN=$(echo $tag | awk '/^v(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-rc[1-9][0-9]*)?$/ {split(substr($1, 2, length($1)-1), a, "\."); print a[2]}')
    if [[ $MAJ != "" && $MIN != "" ]]; then
      #echo cur: $MAJ.$MIN
      if [[ $MAJ > $CUR_MAJ || $MAJ == $CUR_MAJ && $MIN > $CUR_MIN ]]; then
        CUR_MAJ=$MAJ
        CUR_MIN=$MIN
        fi
        #echo max: $CUR_MAJ.$CUR_MIN
    fi
  done

  if [[ $version_bump == "major" ]]; then
    newmaj=$(( $CUR_MAJ + 1 ))
    version="$newmaj.0.0"
  elif [[ $version_bump == "minor" ]]; then
    newmin=$(( $CUR_MIN + 1 ))
    version="$CUR_MAJ.$newmin.0"
  fi
  echo $version
}

# Get all git tags and filter selecting only those with the form "vX.Y.Z[-rcW]".
# Then take the substring "X.Y.Z", break it into the components "X", "Y" and
# "Z[-rcW]" and select only "X" (the major version number). Sort the numbers in
# reverse order and take the first value as the last major version number.
# last_major_version=$(git tag | awk '/^v(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(-rc[1-9][0-9]*)?$/ { split(substr($1, 2, length($1)-1), a, "\."); print a[1] }' | sort -r | head -n 1)
# r=$?
# if [ "$r" -ne 0 ]; then
#   errexit "getting last major version from tag failed"
# elif [ -z "$last_major_version" ]; then
#   echo "No previous major version found, defaulting to 1"
#   next_major_version="1"
# else
#   echo "Last major version found: $last_major_version"
#   next_major_version=$(expr "$last_major_version" '+' '1')
#   r=$?
#   if [ "$r" -ne 0 ]; then
#     errexit "major version number increment failed with return code $r"
#   fi
# fi

version=$(get_new_version)
release_branch="release-$version"
release_tag="v$version"

echo "Changes to be made:"
echo "  new major version will be $next_major_version"
echo "  release tag will be $release_tag"
echo "  will update version in file \"$version_header\""
echo "  will create and checkout branch \"$release_branch\""
echo "You will be prompted for a tag annotation"

if [ "$skip_confirmation" != "TRUE" ]; then
  echo ""
  read -p "Would you like to proceed? [y/N]: " choice
  case "$choice" in
    y|Y )
      ;;
    * )
      echo "Exiting on user command"
      exit 1
      ;;
  esac
fi

git checkout -b "$release_branch" || errexit "failed to checkout branch \"$release_branch\""
echo $version > $version_header   || errexit "unable to create version file \"$version_header\""
git add "$version_header"         || errexit "git add failed"
git commit -m "create-major-release $version"  || errexit "git commit failed"
git tag -a "$release_tag"         || errexit "git tag failed for \"$release_tag\""

echo "Release $version created. Please remember to push with"
echo "  git push origin $release_branch --follow-tags"
exit 0
