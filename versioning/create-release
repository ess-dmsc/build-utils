#!/bin/bash

version_file="VERSION"

# TODO (eventually) - auto commit and push

function errexit()
{
  >&2 echo "! Error: "$1
  exit 1
}

# check if current branch matches the requested branch
function checkbranch()
{
  branch=$1
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  r=$?
  if [ "$r" -ne 0 ]; then
    errexit "\"git rev-parse\" failed with return code $r"
  elif [ "$current_branch" != "$branch" ]; then
    errexit "not in branch $branch"
  fi
}

# Not autoupdate but valled with -u option
function update_build_script()
{
  scriptpath=$(dirname "$0")
  echo "Update this script \"$0\""
  pushd $scriptpath &>/dev/null || errexit "unable to cd into script dir \"$scriptpath\""
    # checkbranch master # eventually ?
    git fetch                   || errexit "git fetch failed"
    git pull                    || errexit "unable to pull latest changes - locally edited?"
  popd &>/dev/null
}

# Initial sanity checks
# for now force call of release script from master branch
checkbranch "master"
test -f $version_file && errexit "\"$version_file\" not allowed in master branch"


# Help text and command line options
usage() {
    echo "USAGE: create-release -r release_type [OPTIONS]"
    echo "  -r release_type   version bump (major/minor/patch)"
    echo ""
    echo "OPTIONS:"
    echo "  -h                print this message and exit"
    echo "  -f                do not prompt for confirmation"
    echo "  -n                do not fetch tags from Git remote"
    echo "  -b branch         for patch releases, specify from_branch (branch-x.y)"
    echo "  -u                update this script"
    echo ""
    echo "RETURNS:"
    echo "  0     success"
    echo "  1     error"
    exit 1
}

skip_confirmation=""
skip_tags_fetch=""
release_type=""
from_branch=""

while getopts "fhnb:r:u" arg; do
  case "${arg}" in
    f)
      skip_confirmation="TRUE"
      ;;
    n)
      skip_tags_fetch="TRUE"
      ;;
    r)
      release_type=$OPTARG
      ;;
    b)
      from_branch=$OPTARG
      ;;
    u)
      update_build_script
      exit 0
      ;;
    h)
      usage
      ;;
  esac
done

shift $((OPTIND-1))

#
# Main release script
#
if [[ $release_type != "major" &&  $release_type != "minor" &&  $release_type != "patch" ]]; then
  errexit "invalid release type - use -r major/minor/patch"
fi

if [[ $release_type == "patch" && $from_branch == "" ]]; then
  errexit "missing from_branch with patch release - use -b relase_x.y"
fi

git_status=$(git status --porcelain)
r=$?
if [ "$r" -ne 0 ]; then
  errexit "\"git status\" failed with return code $r"
elif [ ! -z "$git_status" ]; then
  echo $git_status
  errexit "uncommitted changes or untracked files present"
fi

if [ "$skip_tags_fetch" = "TRUE" ]; then
  echo "Not fetching tags from Git remote"
else
  echo "Fetching tags from Git remote"
  git fetch --tags
  r=$?
  if [ "$r" -ne 0 ]; then
    errexit "\"git fetch\" failed with return code $r"
  fi
fi

# creates global variables CUR_MAJ, CUR_MIN, CUR_PAT used later
function get_cur_version_from_tags()
{
  CUR_MAJ=0
  CUR_MIN=0
  CUR_PAT=0

  tags=$(git tag)

  VER_PATT='/^v(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)$/'

  for tag in $tags
  do
    #echo tag: $tag
    line=$(echo $tag | awk -v patt=$VER_PATT '{split(substr($1, 2, length($1)-1), a, "\."); print a[1], a[2], a[3]}')
    MAJ=$(echo $line | awk '{print $1}')
    MIN=$(echo $line | awk '{print $2}')
    PAT=$(echo $line | awk '{print $3}')

    if [[ $MAJ != "" && $MIN != "" ]]; then
      #echo current line: $MAJ.$MIN.$PAT
      if [[ $MAJ > $CUR_MAJ ||                     \
            $MAJ == $CUR_MAJ && $MIN > $CUR_MIN || \
            $MAJ == $CUR_MAJ && $MIN == $CUR_MIN && $PAT > $CUR_PAT ]]; then
        CUR_MAJ=$MAJ
        CUR_MIN=$MIN
        CUR_PAT=$PAT
      fi
    fi
  done
}


# creates global variables CUR_MAJ, CUR_MIN, CUR_PAT used later
function get_cur_version_from_file()
{
    CUR_MAJ=0
    CUR_MIN=0
    CUR_PAT=0

    test -f $version_file || errexit "No version file ($version_file) in branch"
    line=$(cat $version_file | sed 's/\./ /g')
    CUR_MAJ=$(echo $line | awk '{print $1}')
    CUR_MIN=$(echo $line | awk '{print $2}')
    CUR_PAT=$(echo $line | awk '{print $3}')
}

# Uses the release_type variable
# creates version, release_branch
function make_version_and_tag_strings()
{
  PREV_REL="$CUR_MAJ.$CUR_MIN.$CUR_PAT"

  if [[ $release_type == "major" ]]; then
    newmaj=$(( $CUR_MAJ + 1 ))
    version="$newmaj.0.0"
    release_branch="release-$newmaj.0"
  elif [[ $release_type == "minor" ]]; then
    newmin=$(( $CUR_MIN + 1 ))
    version="$CUR_MAJ.$newmin.0"
    release_branch="release-$CUR_MAJ.$newmin"
  elif [[ $release_type == "patch" ]]; then
    newpatch=$(( $CUR_PAT + 1 ))
    version="$CUR_MAJ.$CUR_MIN.$newpatch"
    release_branch="release-"$CUR_MAJ.$CUR_MIN
  fi
}


echo "Determine latest release"
if [[ $release_type == "patch" ]]; then
  #echo "checking out release branch \"$release_branch\""
  git checkout $from_branch || errexit "from_branch \"$from_branch\" does not exist"
  get_cur_version_from_file
else
  checkbranch "master"
  get_cur_version_from_tags
fi

# must be called after get_cur_version_from....
make_version_and_tag_strings

echo "Previous release: $PREV_REL"
release_tag="v$version"

echo "Changes to be made:"
echo "  new version will be $version"
echo "  release tag will be $release_tag"
echo "  will update version in file \"$version_file\""
echo "  will create/checkout branch \"$release_branch\""
echo "You will be prompted for a tag annotation"

if [ "$skip_confirmation" != "TRUE" ]; then
  echo ""
  read -p "Would you like to proceed? [y/N]: " choice
  if [[ $choice != 'y' ]]; then
      echo "Exiting on user command"
      exit 1
  fi
fi

if [[ $release_type != "patch" ]]; then
  git checkout -b "$release_branch" || errexit "failed to checkout branch \"$release_branch\""
fi
echo $version > $version_file       || errexit "unable to create version file \"$version_file\""
git add "$version_file"             || errexit "git add failed"
git commit -m "create-release $version"  || errexit "git commit failed"
git tag -a "$release_tag"           || errexit "git tag failed for \"$release_tag\""

echo "Release $version created. Please remember to push with"
echo "  git push origin $release_branch --follow-tags"
exit 0
